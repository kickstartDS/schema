import {
  DocumentNode,
  GraphQLObjectType,
  GraphQLNamedType,
  GraphQLFieldMap,
  parse,
  GraphQLField,
  ObjectValueNode,
  ListTypeNode,
  NonNullTypeNode,
  NamedTypeNode
} from "graphql";
import { GraphQLSchema } from "graphql/type/schema";
import {
  buildASTSchema,
} from "graphql/utilities";

export const generate = (schema: GraphQLSchema) => {
  const indentedLine = (level: number) => {
    let line = "\n";
    for (let i = 0; i < level; i++) {
      line += "  ";
    }
    return line;
  }

  const fragmentTypes = {
    DEFAULT: "",
    NO_RELATIONS: "NoNesting",
    DEEP: "DeepNesting"
  };

  const makeFragments = (schema: GraphQLSchema, generator: string) => {
    const ast: GraphQLSchema = schema;

    const typeNames = Object.keys(ast.getTypeMap())
      .filter(
        typeName =>
          ast.getType(typeName) !== undefined
      )
      .filter(
        typeName =>
          (ast.getType(typeName) as GraphQLNamedType).constructor.name === "GraphQLObjectType"
      )
      .filter(typeName => !typeName.startsWith("__"))
      .filter(typeName => typeName !== (ast.getQueryType() as GraphQLObjectType).name)
      .filter(
        typeName =>
          ast.getMutationType()
            ? typeName !== (ast.getMutationType() as GraphQLObjectType)!.name
            : true
      )
      .filter(
        typeName =>
          ast.getSubscriptionType()
            ? typeName !== (ast.getSubscriptionType() as GraphQLObjectType)!.name
            : true
      )
      .sort(
        (a, b) =>
          (ast.getType(a) as GraphQLNamedType).constructor.name < (ast.getType(b) as GraphQLNamedType).constructor.name
            ? -1
            : 1
      );

    const standardFragments = typeNames.map(typeName => {
      const type: any = ast.getType(typeName);
      const { name } = type;

      const fields = generateFragments(type, ast);
      if(fields.length === 0) return null
      return {
        name,
        fragment: `fragment ${name} on ${name} {
  ${fields.join(indentedLine(1))}
}
`
      };
    }).filter(frag => frag != null);

    const noRelationsFragments = typeNames.map(typeName => {
      const type: any = ast.getType(typeName);
      const { name } = type;

      const fields = generateFragments(type, ast, fragmentTypes.NO_RELATIONS);
      if(fields.length === 0) return null
      
      return {
        name,
        fragment: `fragment ${name}${
          fragmentTypes.NO_RELATIONS
        } on ${name} {
  ${fields.join(indentedLine(1))}
}
`
      };
    }).filter(frag => frag != null);
    const deepFragments = typeNames.map(typeName => {
      const type: any = ast.getType(typeName);
      const { name } = type;

      const fields = generateFragments(type, ast, fragmentTypes.DEEP);
        if(fields.length === 0) return null
      return {
        name,
        fragment: `fragment ${name}${fragmentTypes.DEEP} on ${name} {
  ${fields.join(indentedLine(1))}
}
`
      };
    }).filter(frag => frag != null);

    if (generator === "js") {
      return `// THIS FILE HAS BEEN AUTO-GENERATED BY "graphql-cli-generate-fragments"
// DO NOT EDIT THIS FILE DIRECTLY
${standardFragments
        .map(
          ({ name, fragment }) => `
export const ${name}Fragment = \`${fragment}\`
`
        )
        .join("")}
${noRelationsFragments
        .map(
          ({ name, fragment }) => `
export const ${name}${fragmentTypes.NO_RELATIONS}Fragment = \`${fragment}\`
`
        )
        .join("")}
${deepFragments
        .map(
          ({ name, fragment }) => `
export const ${name}${fragmentTypes.DEEP}Fragment = \`${fragment}\`
`
        )
        .join("")}
`;
    }
    return `# THIS FILE HAS BEEN AUTO-GENERATED BY "graphql-cli-generate-fragments"
# DO NOT EDIT THIS FILE DIRECTLY

# Standard Fragments
# Nested fragments will spread one layer deep

${standardFragments
      .map(
        ({ name, fragment }) => `
${fragment}`
      )
      .join("")}

# No Relational objects
# No nested fragments

${noRelationsFragments
      .map(
        ({ name, fragment }) => `
${fragment}`
      )
      .join("")}

# Deeply nested Fragments
# Will include n nested fragments
# If there is a recursive relation you will receive a
# "Cannot spread fragment within itself" error when using

${deepFragments
      .map(
        ({ name, fragment }) => `
${fragment}`
      )
      .join("")}
`;
  }

  const generateFragments = (type: any, ast: GraphQLSchema, fragmentType = fragmentTypes.DEFAULT) => {
    const fields: GraphQLFieldMap<any, any> = type.getFields();
    const fragmentFields = Object.keys(fields)
      .map(field => {
        return printField(field, fields[field], ast, fragmentType);
      })
      // Some fields should not be printed, ie. fields with relations.
      // Remove those from the output by returning null from printField.
      .filter(field => field != null);
    return fragmentFields;
  }

  const printField = (
    fieldName: string,
    field: GraphQLField<any, any> | null,
    ast: GraphQLSchema,
    fragmentType: string,
    indent = 1
  ): any => {
    let constructorName =
      field.type.constructor.name && field.type.constructor.name;
    // console.log('printfield', constructorName, fieldName, field);

    // TODO not sure what this one is about... no idea on how to fix the types
    /*if (constructorName === "Object")
      constructorName =
        ((field.type).name &&
          (ast.getType(field.type.name.value) as GraphQLNamedType).constructor.name) ||
        null;*/
    if (constructorName === "GraphQLList") console.log('printfield before', constructorName, fieldName);
    if (constructorName === "GraphQLList") {
      // field = ((field.astNode.type as ListTypeNode).type as NonNullTypeNode).type

      constructorName = (ast.getType((((field.astNode.type as ListTypeNode).type as NonNullTypeNode).type as NamedTypeNode).name.value) as GraphQLNamedType).constructor.name;
      console.log('printfield after', constructorName, fieldName, field);
    }
    // if (constructorName === "GraphQLList") {
    //   field =
    //     (field.astNode.type.type.type && field.astNode.type.type.type) ||
    //     ((field.astNode.type.type && field.astNode.type.type) || null);

    //   if (field === null) {
    //     throw new Error(`Schema malformed - list`);
    //   }
    //   constructorName = (ast.getType(field.name.value) as GraphQLNamedType).constructor.name;
    // }

    // if (constructorName === "GraphQLNonNull") console.log('printfield', constructorName, fieldName);
    /*if (constructorName === "GraphQLNonNull" || field.kind === "NonNullType") {
      field = (field.astNode.type && field.astNode.type) || field.type;
      constructorName =
        (field.type.name &&
          (ast.getType(field.type.name.value) as GraphQLNamedType).constructor.name) ||
        null;
      if (constructorName === null) {
        field = (field.type && field.type) || null;
        constructorName =
          (field.type.name &&
            (ast.getType(field.type.name.value) as GraphQLNamedType).constructor.name) ||
          null;
      }
    }*/

    // if (constructorName === "GraphQLScalarType") console.log('printfield', constructorName, fieldName);
    // if (constructorName === "GraphQLEnumType") console.log('printfield', constructorName, fieldName);
    /*if (
      constructorName === "GraphQLScalarType" ||
      constructorName === "GraphQLEnumType"
    ) {
      return fieldName;
    }*/

    // if (constructorName === "GraphQLObjectType") console.log('printfield', constructorName, fieldName);
    /*if (constructorName === "GraphQLObjectType") {
      if (fragmentType === this.fragmentType.NO_RELATIONS) return null;
      let typeName = null;
      // if(field.name !== undefined)
      typeName =
        (field.name && field.name.value) ||
        ((field.type.name.value && field.type.name.value) || field.type.name);

      return (
        fieldName +
        " {" +
        this.indentedLine(indent + 1) +
        "..." +
        `${(fragmentType === this.fragmentType.DEEP &&
          typeName + this.fragmentType.DEEP) ||
          (fragmentType === this.fragmentType.DEFAULT &&
          typeName + this.fragmentType.NO_RELATIONS) ||
          typeName + this.fragmentType.DEFAULT}` +
        this.indentedLine(indent) +
        "}"
      );
    }*/

    return null;
  }

  return makeFragments(schema, 'graphql');
};